!function(t){"use strict";let e=class extends Error{name="ConductorError";errorType="__unknown";constructor(t){super(t)}};class s extends e{name="ConductorInternalError";errorType="__internal";constructor(t){super(t)}}async function i(t){return(await import(t)).plugin}let r=class t{t=[];i=[];push(t){this.i.push(t)}pop(){if(0===this.t.length){if(0===this.i.length)throw new Error("queue is empty");let t=this.t;this.t=this.i.reverse(),this.i=t}return this.t.pop()}get length(){return this.t.length+this.i.length}clone(){const e=new t;return e.t=[...this.t],e.i=[...this.i],e}},n=class{h=new r;u=new r;push(t){0!==this.u.length?this.u.pop()(t):this.h.push(t)}async pop(){return 0!==this.h.length?this.h.pop():new Promise(((t,e)=>{this.u.push(t)}))}tryPop(){if(0!==this.h.length)return this.h.pop()}constructor(){this.push=this.push.bind(this)}},h=class{name;t;i=new n;async receive(){return this.i.pop()}tryReceive(){return this.i.tryPop()}send(t,e){this.t.send(t,e)}close(){this.t.unsubscribe(this.i.push)}constructor(t){this.name=t.name,this.t=t,this.t.subscribe(this.i.push)}},o=class{type=0;data;constructor(t,e,s){this.data={fn:t,args:e,invokeId:s}}},a=class{type=2;data;constructor(t,e){this.data={invokeId:t,err:e}}},c=class{type=1;data;constructor(t,e){this.data={invokeId:t,res:e}}};var l;!function(t){t[t.VOID=0]="VOID",t[t.BOOLEAN=1]="BOOLEAN",t[t.NUMBER=2]="NUMBER",t[t.CONST_STRING=3]="CONST_STRING",t[t.EMPTY_LIST=4]="EMPTY_LIST",t[t.PAIR=5]="PAIR",t[t.ARRAY=6]="ARRAY",t[t.CLOSURE=7]="CLOSURE",t[t.OPAQUE=8]="OPAQUE",t[t.LIST=9]="LIST"}(l||(l={}));let u=class{type=1;data;constructor(t){this.data={minVersion:t}}};class p{type=0;data={version:0}}class d{type=3;data;constructor(t){this.data=t}}class _{name="__runner_main";t;i;o;u;h;l;_;p;m;v=new Map([[0,function(t){t.data.version<0?(this.l.send(new u(0)),console.error(`Host's protocol version (${t.data.version}) must be at least 0`)):console.log(`Host is using protocol version ${t.data.version}`)}],[1,function(t){console.error(`Host expects at least protocol version ${t.data.minVersion}, but we are on version 0`),this.o.terminate()}],[2,function(t){this.t.startEvaluator(t.data)}]]);requestFile(t){return this.u.requestFile(t)}async requestChunk(){return(await this.h.receive()).chunk}async requestInput(){const{message:t}=await this._.receive();return t}tryRequestInput(){const t=this._.tryReceive();return t?.message}sendOutput(t){this._.send({message:t})}sendError(t){this.p.send({error:t})}updateStatus(t,e){this.m.send({status:t,isActive:e})}hostLoadPlugin(t){this.l.send(new d(t))}registerPlugin(t,...e){return this.o.registerPlugin(t,...e)}unregisterPlugin(t){this.o.unregisterPlugin(t)}registerModule(t){if(!this.i)throw new s("Evaluator has no data interface");return this.registerPlugin(t,this.t)}unregisterModule(t){this.unregisterPlugin(t)}async importAndRegisterExternalPlugin(t){const e=await i(t);return this.registerPlugin(e)}async importAndRegisterExternalModule(t){const e=await async function(t){return await i(t)}(t);return this.registerModule(e)}static channelAttach=["__file_rpc","__chunk","__service","__stdio","__error","__status"];constructor(t,[e,s,i,r,n,l],u){this.o=t,this.u=function(t,e){const s=[];let i=0;return t.subscribe((async i=>{switch(i.type){case 0:{const{fn:s,args:r,invokeId:n}=i.data;try{const i=await e[s](...r);n>0&&t.send(new c(n,i))}catch(e){n>0&&t.send(new a(n,e))}break}case 1:{const{invokeId:t,res:e}=i.data;s[t]?.[0]?.(e),delete s[t];break}case 2:{const{invokeId:t,err:e}=i.data;s[t]?.[1]?.(e),delete s[t];break}}})),new Proxy({},{get(e,r,n){const h=Reflect.get(e,r,n);if(h)return h;const a="string"==typeof r&&"$"===r.charAt(0)?(...e)=>{t.send(new o(r,e,0))}:(...e)=>{const n=++i;return t.send(new o(r,e,n)),new Promise(((t,e)=>{s[n]=[t,e]}))};return Reflect.set(e,r,a,n),a}})}(e,{}),this.h=new h(s),this.l=i,this._=new h(r),this.p=n,this.m=l,this.l.send(new p),this.l.subscribe((t=>{this.v.get(t.type)?.call(this,t)})),this.t=new u(this),this.i=this.t.hasDataInterface??!1}}class g{name;t;i=new Set;h=!0;o=[];send(t,e){this.l(),this.t.postMessage(t,e??[])}subscribe(t){if(this.l(),this.i.add(t),this.o){for(const e of this.o)t(e);delete this.o}}unsubscribe(t){this.l(),this.i.delete(t)}close(){this.l(),this.h=!1,this.t?.close()}l(){if(!this.h)throw new s(`Channel ${this.name} has been closed`)}_(t){if(this.l(),this.o)this.o.push(t);else for(const e of this.i)e(t)}listenToPort(t){t.addEventListener("message",(t=>this._(t.data))),t.start()}replacePort(t){this.l(),this.t?.close(),this.t=t,this.listenToPort(t)}constructor(t,e){this.name=t,this.replacePort(e)}}class w{u=!0;p;m;C=new Map;P=new Map;v=[];M(t){const{port1:e,port2:s}=new MessageChannel,i=new g(t,e);this.p.postMessage([t,s],[s]),this.C.set(t,i)}l(){if(!this.u)throw new s("Conduit already terminated")}registerPlugin(t,...e){this.l();const i=[];for(const e of t.channelAttach)this.C.has(e)||this.M(e),i.push(this.C.get(e));const r=new t(this,i,...e);if(void 0!==r.name){if(this.P.has(r.name))throw new s(`Plugin ${r.name} already registered`);this.P.set(r.name,r)}return this.v.push(r),r}unregisterPlugin(t){this.l();let e=0;for(let s=0;s<this.v.length;++s)this.v[e]===t&&++e,this.v[s]=this.v[s+e];for(let t=this.v.length-1,s=this.v.length-e;t>=s;--t)delete this.v[t];t.name&&this.P.delete(t.name),t.destroy?.()}lookupPlugin(t){if(this.l(),!this.P.has(t))throw new s(`Plugin ${t} not registered`);return this.P.get(t)}terminate(){this.l();for(const t of this.v)t.destroy?.();this.p.terminate?.(),this.u=!1}j(t){const[e,s]=t;if(this.C.has(e)){const t=this.C.get(e);this.m?t.listenToPort(s):t.replacePort(s)}else{const t=new g(e,s);this.C.set(e,t)}}constructor(t,e=!1){this.p=t,t.addEventListener("message",(t=>this.j(t.data))),this.m=e}}const x=["æ‚‹êœªè„³ë§­ä…¼ã¯§çž†","å¥¤\n+\b\t\t","\t\t\t\t","\b\t\b\t\t\t","",'\b\b!\n\b\r\b\b"',"\t\t&\n\t\r\t\t'\t\t\n","\t\v\r\b\t\n",'2;\v\f""',",","\t","\v\r","","","\t","\v\r"," %","-","/",",\b","1\n","*\f","+!\t",' !"" ','"##',"$&\t%$&'","'%'(","())*\b\t*","\"'\b"].join(""),m=(new t.atn.ATNDeserializer).deserialize(x),v=m.decisionToState.map(((e,s)=>new t.dfa.DFA(e,s)));class T extends t.Lexer{static grammarFileName="SimpleLang.g4";static channelNames=["DEFAULT_TOKEN_CHANNEL","HIDDEN"];static modeNames=["DEFAULT_MODE"];static literalNames=[null,"'+'","'-'","'*'","'/'","'('","')'"];static symbolicNames=[null,null,null,null,null,null,null,"INT","WS"];static ruleNames=["T__0","T__1","T__2","T__3","T__4","T__5","INT","WS"];constructor(e){super(e),this._interp=new t.atn.LexerATNSimulator(this,m,v,new t.PredictionContextCache)}get atn(){return m}}T.EOF=t.Token.EOF,T.T__0=1,T.T__1=2,T.T__2=3,T.T__3=4,T.T__4=5,T.T__5=6,T.INT=7,T.WS=8;class f extends t.tree.ParseTreeListener{enterProg(t){}exitProg(t){}enterExpression(t){}exitExpression(t){}}class E extends t.tree.ParseTreeVisitor{visitProg(t){return this.visitChildren(t)}visitExpression(t){return this.visitChildren(t)}}const P=["æ‚‹êœªè„³ë§­ä…¼ã¯§çž†","å¥¤\n\t\t","","\n","","\n\f\v","","","\b","\b\t\n\b","\n\t\v\f","\f\r\r\b","\t\v","","\f\t","\f\t","","","","",""].join(""),y=(new t.atn.ATNDeserializer).deserialize(P),N=y.decisionToState.map(((e,s)=>new t.dfa.DFA(e,s))),C=new t.PredictionContextCache;class R extends t.Parser{static grammarFileName="SimpleLang.g4";static literalNames=[null,"'+'","'-'","'*'","'/'","'('","')'"];static symbolicNames=[null,null,null,null,null,null,null,"INT","WS"];static ruleNames=["prog","expression"];constructor(e){super(e),this._interp=new t.atn.ParserATNSimulator(this,y,N,C),this.ruleNames=R.ruleNames,this.literalNames=R.literalNames,this.symbolicNames=R.symbolicNames}get atn(){return y}sempred(t,e,s){if(1===e)return this.expression_sempred(t,s);throw"No predicate with index:"+e}expression_sempred(t,e){switch(e){case 0:return this.precpred(this._ctx,4);case 1:return this.precpred(this._ctx,3);default:throw"No predicate with index:"+e}}prog(){let e=new b(this,this._ctx,this.state);this.enterRule(e,0,R.RULE_prog);try{this.enterOuterAlt(e,1),this.state=4,this.expression(0),this.state=5,this.match(R.EOF)}catch(s){if(!(s instanceof t.error.RecognitionException))throw s;e.exception=s,this._errHandler.reportError(this,s),this._errHandler.recover(this,s)}finally{this.exitRule()}return e}expression(e){void 0===e&&(e=0);const s=this._ctx,i=this.state;let r=new I(this,this._ctx,i),n=r;this.enterRecursionRule(r,2,R.RULE_expression,e);var h=0;try{switch(this.enterOuterAlt(r,1),this.state=13,this._errHandler.sync(this),this._input.LA(1)){case R.INT:this.state=8,this.match(R.INT);break;case R.T__4:this.state=9,this.match(R.T__4),this.state=10,this.expression(0),this.state=11,this.match(R.T__5);break;default:throw new t.error.NoViableAltException(this)}this._ctx.stop=this._input.LT(-1),this.state=23,this._errHandler.sync(this);for(var o=this._interp.adaptivePredict(this._input,2,this._ctx);2!=o&&o!=t.atn.ATN.INVALID_ALT_NUMBER;){if(1===o)switch(null!==this._parseListeners&&this.triggerExitRuleEvent(),n=r,this.state=21,this._errHandler.sync(this),this._interp.adaptivePredict(this._input,1,this._ctx)){case 1:if(r=new I(this,s,i),this.pushNewRecursionContext(r,2,R.RULE_expression),this.state=15,!this.precpred(this._ctx,4))throw new t.error.FailedPredicateException(this,"this.precpred(this._ctx, 4)");this.state=16,r.op=this._input.LT(1),(h=this._input.LA(1))!==R.T__0&&h!==R.T__1?r.op=this._errHandler.recoverInline(this):(this._errHandler.reportMatch(this),this.consume()),this.state=17,this.expression(5);break;case 2:if(r=new I(this,s,i),this.pushNewRecursionContext(r,2,R.RULE_expression),this.state=18,!this.precpred(this._ctx,3))throw new t.error.FailedPredicateException(this,"this.precpred(this._ctx, 3)");this.state=19,r.op=this._input.LT(1),(h=this._input.LA(1))!==R.T__2&&h!==R.T__3?r.op=this._errHandler.recoverInline(this):(this._errHandler.reportMatch(this),this.consume()),this.state=20,this.expression(4)}this.state=25,this._errHandler.sync(this),o=this._interp.adaptivePredict(this._input,2,this._ctx)}}catch(e){if(!(e instanceof t.error.RecognitionException))throw e;r.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.unrollRecursionContexts(s)}return r}}R.EOF=t.Token.EOF,R.T__0=1,R.T__1=2,R.T__2=3,R.T__3=4,R.T__4=5,R.T__5=6,R.INT=7,R.WS=8,R.RULE_prog=0,R.RULE_expression=1;class b extends t.ParserRuleContext{constructor(t,e,s){void 0===e&&(e=null),null==s&&(s=-1),super(e,s),this.parser=t,this.ruleIndex=R.RULE_prog}expression(){return this.getTypedRuleContext(I,0)}EOF(){return this.getToken(R.EOF,0)}enterRule(t){t instanceof f&&t.enterProg(this)}exitRule(t){t instanceof f&&t.exitProg(this)}accept(t){return t instanceof E?t.visitProg(this):t.visitChildren(this)}}class I extends t.ParserRuleContext{constructor(t,e,s){void 0===e&&(e=null),null==s&&(s=-1),super(e,s),this.parser=t,this.ruleIndex=R.RULE_expression,this.op=null}INT(){return this.getToken(R.INT,0)}expression=function(t){return void 0===t&&(t=null),null===t?this.getTypedRuleContexts(I):this.getTypedRuleContext(I,t)};enterRule(t){t instanceof f&&t.enterExpression(this)}exitRule(t){t instanceof f&&t.exitExpression(this)}accept(t){return t instanceof E?t.visitExpression(this):t.visitChildren(this)}}R.ProgContext=b,R.ExpressionContext=I;class L{conductor;async startEvaluator(t){const e=await this.conductor.requestFile(t);if(!e)throw new s("Cannot load entrypoint file");for(await this.evaluateFile(t,e);;){const t=await this.conductor.requestChunk();await this.evaluateChunk(t)}}async evaluateFile(t,e){return this.evaluateChunk(e)}constructor(t){this.conductor=t}}class A extends E{visitProg(t){return this.visit(t.expression())}visitExpression(t){if(t.INT())return parseInt(t.INT().getText(),10);if(3===t.getChildCount()){const e=this.visit(t.getChild(0)),s=t.getChild(1).getText(),i=this.visit(t.getChild(2));switch(s){case"+":return e+i;case"-":return e-i;case"*":return e*i;case"/":return e/i}}return 0}}!function(t,e=self){const s=new w(e,!1);s.registerPlugin(_,t)}(class extends L{async evaluateChunk(e){const s=new t.InputStream(e),i=new T(s),r=new t.CommonTokenStream(i),n=new R(r);n.buildParseTrees=!0;const h=n.prog(),o=(new A).visit(h);this.conductor.sendOutput(`result: ${o}`)}constructor(t){super(t)}})}(antlr4);
//# sourceMappingURL=index.js.map
