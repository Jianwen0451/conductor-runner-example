!function(){"use strict";let t=class extends Error{name="ConductorError";errorType="__unknown";constructor(t){super(t)}};class s extends t{name="ConductorInternalError";errorType="__internal";constructor(t){super(t)}}async function e(t){return(await import(t)).plugin}let i=class t{t=[];i=[];push(t){this.i.push(t)}pop(){if(0===this.t.length){if(0===this.i.length)throw new Error("queue is empty");let t=this.t;this.t=this.i.reverse(),this.i=t}return this.t.pop()}get length(){return this.t.length+this.i.length}clone(){const s=new t;return s.t=[...this.t],s.i=[...this.i],s}},n=class{h=new i;u=new i;push(t){0!==this.u.length?this.u.pop()(t):this.h.push(t)}async pop(){return 0!==this.h.length?this.h.pop():new Promise(((t,s)=>{this.u.push(t)}))}tryPop(){if(0!==this.h.length)return this.h.pop()}constructor(){this.push=this.push.bind(this)}},r=class{name;t;i=new n;async receive(){return this.i.pop()}tryReceive(){return this.i.tryPop()}send(t,s){this.t.send(t,s)}close(){this.t.unsubscribe(this.i.push)}constructor(t){this.name=t.name,this.t=t,this.t.subscribe(this.i.push)}},o=class{type=0;data;constructor(t,s,e){this.data={fn:t,args:s,invokeId:e}}},a=class{type=2;data;constructor(t,s){this.data={invokeId:t,err:s}}},h=class{type=1;data;constructor(t,s){this.data={invokeId:t,res:s}}};var u;!function(t){t[t.VOID=0]="VOID",t[t.BOOLEAN=1]="BOOLEAN",t[t.NUMBER=2]="NUMBER",t[t.CONST_STRING=3]="CONST_STRING",t[t.EMPTY_LIST=4]="EMPTY_LIST",t[t.PAIR=5]="PAIR",t[t.ARRAY=6]="ARRAY",t[t.CLOSURE=7]="CLOSURE",t[t.OPAQUE=8]="OPAQUE",t[t.LIST=9]="LIST"}(u||(u={}));let c=class{type=1;data;constructor(t){this.data={minVersion:t}}};class l{type=0;data={version:0}}class d{type=3;data;constructor(t){this.data=t}}class p{name="__runner_main";t;i;o;u;h;l;_;p;m;v=new Map([[0,function(t){t.data.version<0?(this.l.send(new c(0)),console.error(`Host's protocol version (${t.data.version}) must be at least 0`)):console.log(`Host is using protocol version ${t.data.version}`)}],[1,function(t){console.error(`Host expects at least protocol version ${t.data.minVersion}, but we are on version 0`),this.o.terminate()}],[2,function(t){this.t.startEvaluator(t.data)}]]);requestFile(t){return this.u.requestFile(t)}async requestChunk(){return(await this.h.receive()).chunk}async requestInput(){const{message:t}=await this._.receive();return t}tryRequestInput(){const t=this._.tryReceive();return t?.message}sendOutput(t){this._.send({message:t})}sendError(t){this.p.send({error:t})}updateStatus(t,s){this.m.send({status:t,isActive:s})}hostLoadPlugin(t){this.l.send(new d(t))}registerPlugin(t,...s){return this.o.registerPlugin(t,...s)}unregisterPlugin(t){this.o.unregisterPlugin(t)}registerModule(t){if(!this.i)throw new s("Evaluator has no data interface");return this.registerPlugin(t,this.t)}unregisterModule(t){this.unregisterPlugin(t)}async importAndRegisterExternalPlugin(t){const s=await e(t);return this.registerPlugin(s)}async importAndRegisterExternalModule(t){const s=await async function(t){return await e(t)}(t);return this.registerModule(s)}static channelAttach=["__file_rpc","__chunk","__service","__stdio","__error","__status"];constructor(t,[s,e,i,n,u,c],d){this.o=t,this.u=function(t,s){const e=[];let i=0;return t.subscribe((async i=>{switch(i.type){case 0:{const{fn:e,args:n,invokeId:r}=i.data;try{const i=await s[e](...n);r>0&&t.send(new h(r,i))}catch(s){r>0&&t.send(new a(r,s))}break}case 1:{const{invokeId:t,res:s}=i.data;e[t]?.[0]?.(s),delete e[t];break}case 2:{const{invokeId:t,err:s}=i.data;e[t]?.[1]?.(s),delete e[t];break}}})),new Proxy({},{get(s,n,r){const a=Reflect.get(s,n,r);if(a)return a;const h="string"==typeof n&&"$"===n.charAt(0)?(...s)=>{t.send(new o(n,s,0))}:(...s)=>{const r=++i;return t.send(new o(n,s,r)),new Promise(((t,s)=>{e[r]=[t,s]}))};return Reflect.set(s,n,h,r),h}})}(s,{}),this.h=new r(e),this.l=i,this._=new r(n),this.p=u,this.m=c,this.l.send(new l),this.l.subscribe((t=>{this.v.get(t.type)?.call(this,t)})),this.t=new d(this),this.i=this.t.hasDataInterface??!1}}class g{name;t;i=new Set;h=!0;o=[];send(t,s){this.l(),this.t.postMessage(t,s??[])}subscribe(t){if(this.l(),this.i.add(t),this.o){for(const s of this.o)t(s);delete this.o}}unsubscribe(t){this.l(),this.i.delete(t)}close(){this.l(),this.h=!1,this.t?.close()}l(){if(!this.h)throw new s(`Channel ${this.name} has been closed`)}_(t){if(this.l(),this.o)this.o.push(t);else for(const s of this.i)s(t)}listenToPort(t){t.addEventListener("message",(t=>this._(t.data))),t.start()}replacePort(t){this.l(),this.t?.close(),this.t=t,this.listenToPort(t)}constructor(t,s){this.name=t,this.replacePort(s)}}class w{u=!0;p;m;C=new Map;P=new Map;v=[];M(t){const{port1:s,port2:e}=new MessageChannel,i=new g(t,s);this.p.postMessage([t,e],[e]),this.C.set(t,i)}l(){if(!this.u)throw new s("Conduit already terminated")}registerPlugin(t,...e){this.l();const i=[];for(const s of t.channelAttach)this.C.has(s)||this.M(s),i.push(this.C.get(s));const n=new t(this,i,...e);if(void 0!==n.name){if(this.P.has(n.name))throw new s(`Plugin ${n.name} already registered`);this.P.set(n.name,n)}return this.v.push(n),n}unregisterPlugin(t){this.l();let s=0;for(let e=0;e<this.v.length;++e)this.v[s]===t&&++s,this.v[e]=this.v[e+s];for(let t=this.v.length-1,e=this.v.length-s;t>=e;--t)delete this.v[t];t.name&&this.P.delete(t.name),t.destroy?.()}lookupPlugin(t){if(this.l(),!this.P.has(t))throw new s(`Plugin ${t} not registered`);return this.P.get(t)}terminate(){this.l();for(const t of this.v)t.destroy?.();this.p.terminate?.(),this.u=!1}j(t){const[s,e]=t;if(this.C.has(s)){const t=this.C.get(s);this.m?t.listenToPort(e):t.replacePort(e)}else{const t=new g(s,e);this.C.set(s,t)}}constructor(t,s=!1){this.p=t,t.addEventListener("message",(t=>this.j(t.data))),this.m=s}}class v{conductor;async startEvaluator(t){const e=await this.conductor.requestFile(t);if(!e)throw new s("Cannot load entrypoint file");for(await this.evaluateFile(t,e);;){const t=await this.conductor.requestChunk();await this.evaluateChunk(t)}}async evaluateFile(t,s){return this.evaluateChunk(s)}constructor(t){this.conductor=t}}const f=eval;!function(t,s=self){const e=new w(s,!1);e.registerPlugin(p,t)}(class extends v{someEvaluatorState;async evaluateChunk(t){this.someEvaluatorState++,f(t),this.conductor.sendOutput(`Chunk ${this.someEvaluatorState} has been evaluated!`)}constructor(t){super(t),this.someEvaluatorState=0}})}();
//# sourceMappingURL=index.js.map
