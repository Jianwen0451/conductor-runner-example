!function(t){"use strict";let e=class extends Error{name="ConductorError";errorType="__unknown";constructor(t){super(t)}};class s extends e{name="ConductorInternalError";errorType="__internal";constructor(t){super(t)}}async function i(t){return(await import(t)).plugin}let r=class t{t=[];i=[];push(t){this.i.push(t)}pop(){if(0===this.t.length){if(0===this.i.length)throw new Error("queue is empty");let t=this.t;this.t=this.i.reverse(),this.i=t}return this.t.pop()}get length(){return this.t.length+this.i.length}clone(){const e=new t;return e.t=[...this.t],e.i=[...this.i],e}},n=class{h=new r;u=new r;push(t){0!==this.u.length?this.u.pop()(t):this.h.push(t)}async pop(){return 0!==this.h.length?this.h.pop():new Promise(((t,e)=>{this.u.push(t)}))}tryPop(){if(0!==this.h.length)return this.h.pop()}constructor(){this.push=this.push.bind(this)}},h=class{name;t;i=new n;async receive(){return this.i.pop()}tryReceive(){return this.i.tryPop()}send(t,e){this.t.send(t,e)}close(){this.t.unsubscribe(this.i.push)}constructor(t){this.name=t.name,this.t=t,this.t.subscribe(this.i.push)}},a=class{type=0;data;constructor(t,e,s){this.data={fn:t,args:e,invokeId:s}}},o=class{type=2;data;constructor(t,e){this.data={invokeId:t,err:e}}},c=class{type=1;data;constructor(t,e){this.data={invokeId:t,res:e}}};var l;!function(t){t[t.VOID=0]="VOID",t[t.BOOLEAN=1]="BOOLEAN",t[t.NUMBER=2]="NUMBER",t[t.CONST_STRING=3]="CONST_STRING",t[t.EMPTY_LIST=4]="EMPTY_LIST",t[t.PAIR=5]="PAIR",t[t.ARRAY=6]="ARRAY",t[t.CLOSURE=7]="CLOSURE",t[t.OPAQUE=8]="OPAQUE",t[t.LIST=9]="LIST"}(l||(l={}));let u=class{type=1;data;constructor(t){this.data={minVersion:t}}};class p{type=0;data={version:0}}class d{type=3;data;constructor(t){this.data=t}}class _{name="__runner_main";t;i;o;u;h;l;_;p;m;v=new Map([[0,function(t){t.data.version<0?(this.l.send(new u(0)),console.error(`Host's protocol version (${t.data.version}) must be at least 0`)):console.log(`Host is using protocol version ${t.data.version}`)}],[1,function(t){console.error(`Host expects at least protocol version ${t.data.minVersion}, but we are on version 0`),this.o.terminate()}],[2,function(t){this.t.startEvaluator(t.data)}]]);requestFile(t){return this.u.requestFile(t)}async requestChunk(){return(await this.h.receive()).chunk}async requestInput(){const{message:t}=await this._.receive();return t}tryRequestInput(){const t=this._.tryReceive();return t?.message}sendOutput(t){this._.send({message:t})}sendError(t){this.p.send({error:t})}updateStatus(t,e){this.m.send({status:t,isActive:e})}hostLoadPlugin(t){this.l.send(new d(t))}registerPlugin(t,...e){return this.o.registerPlugin(t,...e)}unregisterPlugin(t){this.o.unregisterPlugin(t)}registerModule(t){if(!this.i)throw new s("Evaluator has no data interface");return this.registerPlugin(t,this.t)}unregisterModule(t){this.unregisterPlugin(t)}async importAndRegisterExternalPlugin(t){const e=await i(t);return this.registerPlugin(e)}async importAndRegisterExternalModule(t){const e=await async function(t){return await i(t)}(t);return this.registerModule(e)}static channelAttach=["__file_rpc","__chunk","__service","__stdio","__error","__status"];constructor(t,[e,s,i,r,n,l],u){this.o=t,this.u=function(t,e){const s=[];let i=0;return t.subscribe((async i=>{switch(i.type){case 0:{const{fn:s,args:r,invokeId:n}=i.data;try{const i=await e[s](...r);n>0&&t.send(new c(n,i))}catch(e){n>0&&t.send(new o(n,e))}break}case 1:{const{invokeId:t,res:e}=i.data;s[t]?.[0]?.(e),delete s[t];break}case 2:{const{invokeId:t,err:e}=i.data;s[t]?.[1]?.(e),delete s[t];break}}})),new Proxy({},{get(e,r,n){const h=Reflect.get(e,r,n);if(h)return h;const o="string"==typeof r&&"$"===r.charAt(0)?(...e)=>{t.send(new a(r,e,0))}:(...e)=>{const n=++i;return t.send(new a(r,e,n)),new Promise(((t,e)=>{s[n]=[t,e]}))};return Reflect.set(e,r,o,n),o}})}(e,{}),this.h=new h(s),this.l=i,this._=new h(r),this.p=n,this.m=l,this.l.send(new p),this.l.subscribe((t=>{this.v.get(t.type)?.call(this,t)})),this.t=new u(this),this.i=this.t.hasDataInterface??!1}}class g{name;t;i=new Set;h=!0;o=[];send(t,e){this.l(),this.t.postMessage(t,e??[])}subscribe(t){if(this.l(),this.i.add(t),this.o){for(const e of this.o)t(e);delete this.o}}unsubscribe(t){this.l(),this.i.delete(t)}close(){this.l(),this.h=!1,this.t?.close()}l(){if(!this.h)throw new s(`Channel ${this.name} has been closed`)}_(t){if(this.l(),this.o)this.o.push(t);else for(const e of this.i)e(t)}listenToPort(t){t.addEventListener("message",(t=>this._(t.data))),t.start()}replacePort(t){this.l(),this.t?.close(),this.t=t,this.listenToPort(t)}constructor(t,e){this.name=t,this.replacePort(e)}}class w{u=!0;p;m;C=new Map;P=new Map;v=[];M(t){const{port1:e,port2:s}=new MessageChannel,i=new g(t,e);this.p.postMessage([t,s],[s]),this.C.set(t,i)}l(){if(!this.u)throw new s("Conduit already terminated")}registerPlugin(t,...e){this.l();const i=[];for(const e of t.channelAttach)this.C.has(e)||this.M(e),i.push(this.C.get(e));const r=new t(this,i,...e);if(void 0!==r.name){if(this.P.has(r.name))throw new s(`Plugin ${r.name} already registered`);this.P.set(r.name,r)}return this.v.push(r),r}unregisterPlugin(t){this.l();let e=0;for(let s=0;s<this.v.length;++s)this.v[e]===t&&++e,this.v[s]=this.v[s+e];for(let t=this.v.length-1,s=this.v.length-e;t>=s;--t)delete this.v[t];t.name&&this.P.delete(t.name),t.destroy?.()}lookupPlugin(t){if(this.l(),!this.P.has(t))throw new s(`Plugin ${t} not registered`);return this.P.get(t)}terminate(){this.l();for(const t of this.v)t.destroy?.();this.p.terminate?.(),this.u=!1}j(t){const[e,s]=t;if(this.C.has(e)){const t=this.C.get(e);this.m?t.listenToPort(s):t.replacePort(s)}else{const t=new g(e,s);this.C.set(e,t)}}constructor(t,e=!1){this.p=t,t.addEventListener("message",(t=>this.j(t.data))),this.m=e}}const x=(new t.atn.ATNDeserializer).deserialize([4,0,8,41,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,7,7,1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,4,1,4,1,5,1,5,1,6,4,6,31,8,6,11,6,12,6,32,1,7,4,7,36,8,7,11,7,12,7,37,1,7,1,7,0,0,8,1,1,3,2,5,3,7,4,9,5,11,6,13,7,15,8,1,0,2,1,0,48,57,3,0,9,10,13,13,32,32,42,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,0,0,11,1,0,0,0,0,13,1,0,0,0,0,15,1,0,0,0,1,17,1,0,0,0,3,19,1,0,0,0,5,21,1,0,0,0,7,23,1,0,0,0,9,25,1,0,0,0,11,27,1,0,0,0,13,30,1,0,0,0,15,35,1,0,0,0,17,18,5,43,0,0,18,2,1,0,0,0,19,20,5,45,0,0,20,4,1,0,0,0,21,22,5,42,0,0,22,6,1,0,0,0,23,24,5,47,0,0,24,8,1,0,0,0,25,26,5,40,0,0,26,10,1,0,0,0,27,28,5,41,0,0,28,12,1,0,0,0,29,31,7,0,0,0,30,29,1,0,0,0,31,32,1,0,0,0,32,30,1,0,0,0,32,33,1,0,0,0,33,14,1,0,0,0,34,36,7,1,0,0,35,34,1,0,0,0,36,37,1,0,0,0,37,35,1,0,0,0,37,38,1,0,0,0,38,39,1,0,0,0,39,40,6,7,0,0,40,16,1,0,0,0,3,0,32,37,1,6,0,0]),m=x.decisionToState.map(((e,s)=>new t.dfa.DFA(e,s)));class v extends t.Lexer{static grammarFileName="SimpleLang.g4";static channelNames=["DEFAULT_TOKEN_CHANNEL","HIDDEN"];static modeNames=["DEFAULT_MODE"];static literalNames=[null,"'+'","'-'","'*'","'/'","'('","')'"];static symbolicNames=[null,null,null,null,null,null,null,"INT","WS"];static ruleNames=["T__0","T__1","T__2","T__3","T__4","T__5","INT","WS"];constructor(e){super(e),this._interp=new t.atn.LexerATNSimulator(this,x,m,new t.atn.PredictionContextCache)}}v.EOF=t.Token.EOF,v.T__0=1,v.T__1=2,v.T__2=3,v.T__3=4,v.T__4=5,v.T__5=6,v.INT=7,v.WS=8;class T extends t.tree.ParseTreeListener{enterProg(t){}exitProg(t){}enterExpression(t){}exitExpression(t){}}class f extends t.tree.ParseTreeVisitor{visitProg(t){return this.visitChildren(t)}visitExpression(t){return this.visitChildren(t)}}const E=(new t.atn.ATNDeserializer).deserialize([4,1,8,27,2,0,7,0,2,1,7,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,14,8,1,1,1,1,1,1,1,1,1,1,1,1,1,5,1,22,8,1,10,1,12,1,25,9,1,1,1,0,1,2,2,0,2,0,2,1,0,1,2,1,0,3,4,27,0,4,1,0,0,0,2,13,1,0,0,0,4,5,3,2,1,0,5,6,5,0,0,1,6,1,1,0,0,0,7,8,6,1,-1,0,8,14,5,7,0,0,9,10,5,5,0,0,10,11,3,2,1,0,11,12,5,6,0,0,12,14,1,0,0,0,13,7,1,0,0,0,13,9,1,0,0,0,14,23,1,0,0,0,15,16,10,4,0,0,16,17,7,0,0,0,17,22,3,2,1,5,18,19,10,3,0,0,19,20,7,1,0,0,20,22,3,2,1,4,21,15,1,0,0,0,21,18,1,0,0,0,22,25,1,0,0,0,23,21,1,0,0,0,23,24,1,0,0,0,24,3,1,0,0,0,25,23,1,0,0,0,3,13,21,23]),P=E.decisionToState.map(((e,s)=>new t.dfa.DFA(e,s))),y=new t.atn.PredictionContextCache;class N extends t.Parser{static grammarFileName="SimpleLang.g4";static literalNames=[null,"'+'","'-'","'*'","'/'","'('","')'"];static symbolicNames=[null,null,null,null,null,null,null,"INT","WS"];static ruleNames=["prog","expression"];constructor(e){super(e),this._interp=new t.atn.ParserATNSimulator(this,E,P,y),this.ruleNames=N.ruleNames,this.literalNames=N.literalNames,this.symbolicNames=N.symbolicNames}sempred(t,e,s){if(1===e)return this.expression_sempred(t,s);throw"No predicate with index:"+e}expression_sempred(t,e){switch(e){case 0:return this.precpred(this._ctx,4);case 1:return this.precpred(this._ctx,3);default:throw"No predicate with index:"+e}}prog(){let e=new C(this,this._ctx,this.state);this.enterRule(e,0,N.RULE_prog);try{this.enterOuterAlt(e,1),this.state=4,this.expression(0),this.state=5,this.match(N.EOF)}catch(s){if(!(s instanceof t.error.RecognitionException))throw s;e.exception=s,this._errHandler.reportError(this,s),this._errHandler.recover(this,s)}finally{this.exitRule()}return e}expression(e){void 0===e&&(e=0);const s=this._ctx,i=this.state;let r=new R(this,this._ctx,i),n=r;this.enterRecursionRule(r,2,N.RULE_expression,e);var h=0;try{switch(this.enterOuterAlt(r,1),this.state=13,this._errHandler.sync(this),this._input.LA(1)){case 7:this.state=8,this.match(N.INT);break;case 5:this.state=9,this.match(N.T__4),this.state=10,this.expression(0),this.state=11,this.match(N.T__5);break;default:throw new t.error.NoViableAltException(this)}this._ctx.stop=this._input.LT(-1),this.state=23,this._errHandler.sync(this);for(var a=this._interp.adaptivePredict(this._input,2,this._ctx);2!=a&&a!=t.atn.ATN.INVALID_ALT_NUMBER;){if(1===a)switch(null!==this._parseListeners&&this.triggerExitRuleEvent(),n=r,this.state=21,this._errHandler.sync(this),this._interp.adaptivePredict(this._input,1,this._ctx)){case 1:if(r=new R(this,s,i),this.pushNewRecursionContext(r,2,N.RULE_expression),this.state=15,!this.precpred(this._ctx,4))throw new t.error.FailedPredicateException(this,"this.precpred(this._ctx, 4)");this.state=16,r.op=this._input.LT(1),1!==(h=this._input.LA(1))&&2!==h?r.op=this._errHandler.recoverInline(this):(this._errHandler.reportMatch(this),this.consume()),this.state=17,this.expression(5);break;case 2:if(r=new R(this,s,i),this.pushNewRecursionContext(r,2,N.RULE_expression),this.state=18,!this.precpred(this._ctx,3))throw new t.error.FailedPredicateException(this,"this.precpred(this._ctx, 3)");this.state=19,r.op=this._input.LT(1),3!==(h=this._input.LA(1))&&4!==h?r.op=this._errHandler.recoverInline(this):(this._errHandler.reportMatch(this),this.consume()),this.state=20,this.expression(4)}this.state=25,this._errHandler.sync(this),a=this._interp.adaptivePredict(this._input,2,this._ctx)}}catch(e){if(!(e instanceof t.error.RecognitionException))throw e;r.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.unrollRecursionContexts(s)}return r}}N.EOF=t.Token.EOF,N.T__0=1,N.T__1=2,N.T__2=3,N.T__3=4,N.T__4=5,N.T__5=6,N.INT=7,N.WS=8,N.RULE_prog=0,N.RULE_expression=1;class C extends t.ParserRuleContext{constructor(t,e,s){void 0===e&&(e=null),null==s&&(s=-1),super(e,s),this.parser=t,this.ruleIndex=N.RULE_prog}expression(){return this.getTypedRuleContext(R,0)}EOF(){return this.getToken(N.EOF,0)}enterRule(t){t instanceof T&&t.enterProg(this)}exitRule(t){t instanceof T&&t.exitProg(this)}accept(t){return t instanceof f?t.visitProg(this):t.visitChildren(this)}}class R extends t.ParserRuleContext{constructor(t,e,s){void 0===e&&(e=null),null==s&&(s=-1),super(e,s),this.parser=t,this.ruleIndex=N.RULE_expression,this.op=null}INT(){return this.getToken(N.INT,0)}expression=function(t){return void 0===t&&(t=null),null===t?this.getTypedRuleContexts(R):this.getTypedRuleContext(R,t)};enterRule(t){t instanceof T&&t.enterExpression(this)}exitRule(t){t instanceof T&&t.exitExpression(this)}accept(t){return t instanceof f?t.visitExpression(this):t.visitChildren(this)}}N.ProgContext=C,N.ExpressionContext=R;class I{conductor;async startEvaluator(t){const e=await this.conductor.requestFile(t);if(!e)throw new s("Cannot load entrypoint file");for(await this.evaluateFile(t,e);;){const t=await this.conductor.requestChunk();await this.evaluateChunk(t)}}async evaluateFile(t,e){return this.evaluateChunk(e)}constructor(t){this.conductor=t}}class L extends f{visitProg(t){return this.visit(t.expression())}visitExpression(t){if(t.INT())return parseInt(t.INT().getText(),10);if(3===t.getChildCount()){const e=this.visit(t.getChild(0)),s=t.getChild(1).getText(),i=this.visit(t.getChild(2));switch(s){case"+":return e+i;case"-":return e-i;case"*":return e*i;case"/":return e/i}}return 0}}!function(t,e=self){const s=new w(e,!1);s.registerPlugin(_,t)}(class extends I{async evaluateChunk(e){const s=new t.InputStream(e),i=new v(s),r=new t.CommonTokenStream(i),n=new N(r);n.buildParseTrees=!0;const h=n.prog(),a=(new L).visit(h);this.conductor.sendOutput(`result: ${a}`)}constructor(t){super(t)}})}(antlr4);
//# sourceMappingURL=index.js.map
